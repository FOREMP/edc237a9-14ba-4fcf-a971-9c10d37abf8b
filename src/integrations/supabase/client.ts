
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://zgcsgwlggvjvvshhhcmb.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InpnY3Nnd2xnZ3ZqdnZzaGhoY21iIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDM0NTAwMTUsImV4cCI6MjA1OTAyNjAxNX0.rquwTuuTUAVWbv9qD47dGDJ_5eRd1mZYHJqVFIzIDMs";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Configure the client with explicit authentication settings
export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    autoRefreshToken: true,
    persistSession: true,
    storage: localStorage,
    detectSessionInUrl: true,
    flowType: 'pkce'  // Added explicit PKCE flow type for better security
  },
  global: {
    headers: {
      'x-client-info': 'lovable-web'  // Add client info for better debugging
    }
  },
  realtime: {
    params: {
      eventsPerSecond: 10
    }
  },
  db: {
    schema: 'public'
  }
});

// Export a utility function to clean up auth state
export const cleanupAuthState = () => {
  try {
    // Remove all Supabase auth keys from localStorage
    Object.keys(localStorage).forEach((key) => {
      if (key.startsWith('supabase.auth.') || key.includes('sb-')) {
        localStorage.removeItem(key);
      }
    });
    
    // Remove from sessionStorage if in use
    if (typeof sessionStorage !== 'undefined') {
      Object.keys(sessionStorage).forEach((key) => {
        if (key.startsWith('supabase.auth.') || key.includes('sb-')) {
          sessionStorage.removeItem(key);
        }
      });
    }
    
    // Additional cleanup for any custom auth state
    localStorage.removeItem('auth-state');
    localStorage.removeItem('auth-user');
    localStorage.removeItem('auth-session');
    
    // Force browser to forget cached auth state
    if (navigator && navigator.serviceWorker) {
      try {
        navigator.serviceWorker.ready.then(registration => {
          registration.active?.postMessage({
            type: 'CLEAR_AUTH_CACHE'
          });
        });
      } catch (e) {
        console.warn("Could not clear service worker cache:", e);
      }
    }
    
    console.log("Auth state cleanup completed");
  } catch (e) {
    console.error("Error cleaning up auth state:", e);
  }
};

// Add a diagnostic helper function for debugging RLS issues
export const testRlsPermissions = async (userId: string) => {
  try {
    // Test profiles access
    const profileResult = await supabase
      .from('profiles')
      .select('*')
      .eq('id', userId)
      .single();
    
    // Test preferences access
    const prefsResult = await supabase
      .from('user_preferences')
      .select('*')
      .eq('user_id', userId)
      .maybeSingle();
    
    // Test job posting limits access
    const limitsResult = await supabase
      .from('job_posting_limits')
      .select('*')
      .eq('user_id', userId)
      .maybeSingle();
    
    // Test subscribers table access
    const subResult = await supabase
      .from('subscribers')
      .select('*')
      .eq('user_id', userId)
      .maybeSingle();
      
    // Test jobs table access
    const jobsResult = await supabase
      .from('jobs')
      .select('*')
      .eq('company_id', userId)
      .limit(1);
    
    // Test job_views table access
    // First get a job id if possible
    let jobId = null;
    if (jobsResult.data && jobsResult.data.length > 0) {
      jobId = jobsResult.data[0].id;
      
      // Now test job_views access
      const viewsResult = await supabase
        .from('job_views')
        .select('count(*)')
        .eq('job_id', jobId.toString())
        .limit(1);
        
      return {
        timestamp: new Date().toISOString(),
        tests: {
          profiles: { 
            success: !profileResult.error, 
            error: profileResult.error?.message || null,
            data: profileResult.data ? 'Data found' : 'No data'
          },
          preferences: { 
            success: !prefsResult.error, 
            error: prefsResult.error?.message || null,
            data: prefsResult.data ? 'Data found' : 'No data'
          },
          jobLimits: { 
            success: !limitsResult.error, 
            error: limitsResult.error?.message || null,
            data: limitsResult.data ? 'Data found' : 'No data'
          },
          subscribers: { 
            success: !subResult.error, 
            error: subResult.error?.message || null,
            data: subResult.data ? 'Data found' : 'No data'
          },
          jobs: {
            success: !jobsResult.error,
            error: jobsResult.error?.message || null,
            data: jobsResult.data?.length > 0 ? `Found ${jobsResult.data.length} jobs` : 'No jobs found'
          },
          jobViews: {
            success: jobId ? true : false,
            error: jobId ? null : 'No job ID available to test views',
            tested: !!jobId
          }
        },
        userId
      };
    }
    
    return {
      timestamp: new Date().toISOString(),
      tests: {
        profiles: { 
          success: !profileResult.error, 
          error: profileResult.error?.message || null,
          data: profileResult.data ? 'Data found' : 'No data'
        },
        preferences: { 
          success: !prefsResult.error, 
          error: prefsResult.error?.message || null,
          data: prefsResult.data ? 'Data found' : 'No data'
        },
        jobLimits: { 
          success: !limitsResult.error, 
          error: limitsResult.error?.message || null,
          data: limitsResult.data ? 'Data found' : 'No data'
        },
        subscribers: { 
          success: !subResult.error, 
          error: subResult.error?.message || null,
          data: subResult.data ? 'Data found' : 'No data'
        },
        jobs: {
          success: !jobsResult.error,
          error: jobsResult.error?.message || null,
          data: jobsResult.data?.length > 0 ? `Found ${jobsResult.data.length} jobs` : 'No jobs found'
        },
        jobViews: {
          success: false,
          error: 'No job ID available to test views',
          tested: false
        }
      },
      userId
    };
  } catch (error) {
    return {
      timestamp: new Date().toISOString(),
      error: error instanceof Error ? error.message : String(error),
      userId
    };
  }
};

// Add helper to diagnose company access specifically
export const diagCompanyAccess = async () => {
  try {
    // First get the current user
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) {
      return { error: "No authenticated user found" };
    }
    
    console.log("Diagnosing company access for user:", user.email);
    
    // Test session validity
    const { data: sessionData } = await supabase.auth.getSession();
    const hasValidSession = !!sessionData?.session;
    
    // Get current user's role from profile
    const { data: profileData, error: profileError } = await supabase
      .from('profiles')
      .select('role, email, company_name')
      .eq('id', user.id)
      .single();
      
    if (profileError) {
      console.error("Cannot access profile:", profileError);
      return {
        error: "Profile access failed",
        message: profileError.message,
        session: hasValidSession ? "Valid" : "Invalid",
        userId: user.id,
        userEmail: user.email
      };
    }
    
    // Get job count
    const { data: jobsData, error: jobsError } = await supabase
      .from('jobs')
      .select('id', { count: 'exact' })
      .eq('company_id', user.id);
      
    // Test full permissions
    const fullTest = await testRlsPermissions(user.id);
    
    return {
      success: true,
      user: {
        id: user.id,
        email: user.email,
        role: profileData?.role,
        companyName: profileData?.company_name
      },
      session: hasValidSession ? "Valid" : "Invalid",
      jobCount: jobsError ? "Error accessing jobs" : (jobsData?.length || 0),
      fullTest
    };
  } catch (error) {
    console.error("Error in company access diagnosis:", error);
    return { 
      error: "Diagnosis failed", 
      message: error instanceof Error ? error.message : String(error) 
    };
  }
};
