
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://zgcsgwlggvjvvshhhcmb.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InpnY3Nnd2xnZ3ZqdnZzaGhoY21iIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDM0NTAwMTUsImV4cCI6MjA1OTAyNjAxNX0.rquwTuuTUAVWbv9qD47dGDJ_5eRd1mZYHJqVFIzIDMs";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Configure the client with explicit authentication settings
export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    autoRefreshToken: true,
    persistSession: true,
    storage: localStorage,
    detectSessionInUrl: true,
    flowType: 'pkce'  // Added explicit PKCE flow type for better security
  },
  global: {
    headers: {
      'x-client-info': 'lovable-web'  // Add client info for better debugging
    }
  },
  realtime: {
    params: {
      eventsPerSecond: 10
    }
  },
  db: {
    schema: 'public'
  }
});

// Add debug wrapper to track all Supabase queries
const originalFrom = supabase.from.bind(supabase);
supabase.from = function(table: string) {
  const result = originalFrom(table);
  
  // Debug helper for select
  const originalSelect = result.select.bind(result);
  result.select = function(...args: any[]) {
    const query = originalSelect(...args);
    
    // Debug wrapper for query execution
    const originalThen = query.then.bind(query);
    query.then = function(onfulfilled?: any, onrejected?: any) {
      console.log(`[Supabase Debug] Executing SELECT on ${table} with args:`, args);
      
      return originalThen(
        (result: any) => {
          console.log(`[Supabase Debug] SELECT on ${table} completed:`, {
            success: !result.error,
            count: Array.isArray(result.data) ? result.data.length : (result.data ? 1 : 0),
            error: result.error
          });
          return onfulfilled ? onfulfilled(result) : result;
        },
        (error: any) => {
          console.error(`[Supabase Debug] SELECT on ${table} failed:`, error);
          return onrejected ? onrejected(error) : Promise.reject(error);
        }
      );
    };
    
    return query;
  };
  
  return result;
};

// Export a utility function to clean up auth state
export const cleanupAuthState = () => {
  try {
    // Remove all Supabase auth keys from localStorage
    Object.keys(localStorage).forEach((key) => {
      if (key.startsWith('supabase.auth.') || key.includes('sb-')) {
        localStorage.removeItem(key);
      }
    });
    
    // Remove from sessionStorage if in use
    if (typeof sessionStorage !== 'undefined') {
      Object.keys(sessionStorage).forEach((key) => {
        if (key.startsWith('supabase.auth.') || key.includes('sb-')) {
          sessionStorage.removeItem(key);
        }
      });
    }
    
    // Additional cleanup for any custom auth state
    localStorage.removeItem('auth-state');
    localStorage.removeItem('auth-user');
    localStorage.removeItem('auth-session');
    
    // Force browser to forget cached auth state
    if (navigator && navigator.serviceWorker) {
      try {
        navigator.serviceWorker.ready.then(registration => {
          registration.active?.postMessage({
            type: 'CLEAR_AUTH_CACHE'
          });
        });
      } catch (e) {
        console.warn("Could not clear service worker cache:", e);
      }
    }
    
    console.log("Auth state cleanup completed");
  } catch (e) {
    console.error("Error cleaning up auth state:", e);
  }
};

// Add a diagnostic helper function for debugging RLS issues
export const testRlsPermissions = async (userId: string) => {
  try {
    // Test profiles access
    const profileResult = await supabase
      .from('profiles')
      .select('*')
      .eq('id', userId)
      .single();
    
    // Test preferences access
    const prefsResult = await supabase
      .from('user_preferences')
      .select('*')
      .eq('user_id', userId)
      .maybeSingle();
    
    // Test job posting limits access
    const limitsResult = await supabase
      .from('job_posting_limits')
      .select('*')
      .eq('user_id', userId)
      .maybeSingle();
    
    // Test subscribers table access
    const subResult = await supabase
      .from('subscribers')
      .select('*')
      .eq('user_id', userId)
      .maybeSingle();
      
    // Test jobs table access
    const jobsResult = await supabase
      .from('jobs')
      .select('*')
      .eq('company_id', userId)
      .limit(1);
    
    // Test job_views table access
    // First get a job id if possible
    let jobId = null;
    if (jobsResult.data && jobsResult.data.length > 0) {
      jobId = jobsResult.data[0].id;
      
      // Now test job_views access
      const viewsResult = await supabase
        .from('job_views')
        .select('count(*)')
        .eq('job_id', jobId.toString())
        .limit(1);
        
      return {
        timestamp: new Date().toISOString(),
        tests: {
          profiles: { 
            success: !profileResult.error, 
            error: profileResult.error?.message || null,
            data: profileResult.data ? 'Data found' : 'No data'
          },
          preferences: { 
            success: !prefsResult.error, 
            error: prefsResult.error?.message || null,
            data: prefsResult.data ? 'Data found' : 'No data'
          },
          jobLimits: { 
            success: !limitsResult.error, 
            error: limitsResult.error?.message || null,
            data: limitsResult.data ? 'Data found' : 'No data'
          },
          subscribers: { 
            success: !subResult.error, 
            error: subResult.error?.message || null,
            data: subResult.data ? 'Data found' : 'No data'
          },
          jobs: {
            success: !jobsResult.error,
            error: jobsResult.error?.message || null,
            data: jobsResult.data?.length > 0 ? `Found ${jobsResult.data.length} jobs` : 'No jobs found'
          },
          jobViews: {
            success: jobId ? true : false,
            error: jobId ? null : 'No job ID available to test views',
            tested: !!jobId
          }
        },
        userId
      };
    }
    
    return {
      timestamp: new Date().toISOString(),
      tests: {
        profiles: { 
          success: !profileResult.error, 
          error: profileResult.error?.message || null,
          data: profileResult.data ? 'Data found' : 'No data'
        },
        preferences: { 
          success: !prefsResult.error, 
          error: prefsResult.error?.message || null,
          data: prefsResult.data ? 'Data found' : 'No data'
        },
        jobLimits: { 
          success: !limitsResult.error, 
          error: limitsResult.error?.message || null,
          data: limitsResult.data ? 'Data found' : 'No data'
        },
        subscribers: { 
          success: !subResult.error, 
          error: subResult.error?.message || null,
          data: subResult.data ? 'Data found' : 'No data'
        },
        jobs: {
          success: !jobsResult.error,
          error: jobsResult.error?.message || null,
          data: jobsResult.data?.length > 0 ? `Found ${jobsResult.data.length} jobs` : 'No jobs found'
        },
        jobViews: {
          success: false,
          error: 'No job ID available to test views',
          tested: false
        }
      },
      userId
    };
  } catch (error) {
    return {
      timestamp: new Date().toISOString(),
      error: error instanceof Error ? error.message : String(error),
      userId
    };
  }
};

// Add helper to diagnose company access specifically
export const diagCompanyAccess = async () => {
  try {
    // First get the current user
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) {
      return { error: "No authenticated user found" };
    }
    
    console.log("Diagnosing company access for user:", user.email);
    
    // Test session validity
    const { data: sessionData } = await supabase.auth.getSession();
    const hasValidSession = !!sessionData?.session;
    
    // Get current user's role from profile
    const { data: profileData, error: profileError } = await supabase
      .from('profiles')
      .select('role, email, company_name')
      .eq('id', user.id)
      .single();
      
    if (profileError) {
      console.error("Cannot access profile:", profileError);
      return {
        error: "Profile access failed",
        message: profileError.message,
        session: hasValidSession ? "Valid" : "Invalid",
        userId: user.id,
        userEmail: user.email
      };
    }
    
    // Get job count
    const { data: jobsData, error: jobsError } = await supabase
      .from('jobs')
      .select('id', { count: 'exact' })
      .eq('company_id', user.id);
      
    // Test full permissions
    const fullTest = await testRlsPermissions(user.id);
    
    return {
      success: true,
      user: {
        id: user.id,
        email: user.email,
        role: profileData?.role,
        companyName: profileData?.company_name
      },
      session: hasValidSession ? "Valid" : "Invalid",
      jobCount: jobsError ? "Error accessing jobs" : (jobsData?.length || 0),
      fullTest
    };
  } catch (error) {
    console.error("Error in company access diagnosis:", error);
    return { 
      error: "Diagnosis failed", 
      message: error instanceof Error ? error.message : String(error) 
    };
  }
};

// NEW: Function to check if table contains any data for a user
export const checkTableData = async (userId: string) => {
  try {
    // Check profiles
    const { data: profileData, error: profileError } = await supabase
      .from('profiles')
      .select('id')
      .eq('id', userId);
      
    // Check jobs
    const { data: jobsData, error: jobsError } = await supabase
      .from('jobs')
      .select('id')
      .eq('company_id', userId);
      
    // Check subscribers
    const { data: subsData, error: subsError } = await supabase
      .from('subscribers')
      .select('id')
      .eq('user_id', userId);
      
    // Check posting limits
    const { data: limitsData, error: limitsError } = await supabase
      .from('job_posting_limits')
      .select('id')
      .eq('user_id', userId);
      
    // Check preferences
    const { data: prefsData, error: prefsError } = await supabase
      .from('user_preferences')
      .select('id')
      .eq('user_id', userId);
    
    return {
      profiles: {
        error: profileError?.message,
        count: profileData?.length || 0
      },
      jobs: {
        error: jobsError?.message,
        count: jobsData?.length || 0
      },
      subscribers: {
        error: subsError?.message,
        count: subsData?.length || 0
      },
      jobPostingLimits: {
        error: limitsError?.message,
        count: limitsData?.length || 0
      },
      userPreferences: {
        error: prefsError?.message,
        count: prefsData?.length || 0
      }
    };
  } catch (error) {
    return {
      error: error instanceof Error ? error.message : String(error)
    };
  }
};

// NEW: Function to fix RLS policy issues
export const fixCommonRlsIssues = async () => {
  try {
    // Check if we need to insert user data
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) {
      return { error: "No authenticated user found" };
    }
    
    const checkResult = await checkTableData(user.id);
    console.log("Data check result:", checkResult);
    
    let fixResults = {
      profilesFixed: false,
      preferencesFixed: false,
      subscribersFixed: false,
      limitsFixed: false
    };
    
    // Fix missing profile if needed
    if (checkResult.profiles?.count === 0) {
      console.log("Attempting to fix missing profile...");
      const { data: emailCheck } = await supabase.auth.getUser();
      
      if (emailCheck.user) {
        const { error } = await supabase
          .from('profiles')
          .insert({
            id: user.id,
            email: emailCheck.user.email || 'unknown@example.com',
            role: 'company',
            company_name: 'Your Company'
          });
        
        fixResults.profilesFixed = !error;
      }
    }
    
    // Fix missing preferences if needed
    if (checkResult.userPreferences?.count === 0) {
      console.log("Attempting to fix missing user preferences...");
      const { error } = await supabase
        .from('user_preferences')
        .insert({
          user_id: user.id
        });
      
      fixResults.preferencesFixed = !error;
    }
    
    // Fix missing subscribers entry if needed
    if (checkResult.subscribers?.count === 0) {
      console.log("Attempting to fix missing subscriber record...");
      const { error } = await supabase
        .from('subscribers')
        .insert({
          user_id: user.id,
          email: user.email || 'unknown@example.com',
          subscribed: false,
          subscription_tier: 'free'
        });
      
      fixResults.subscribersFixed = !error;
    }
    
    // Fix missing job posting limits if needed
    if (checkResult.jobPostingLimits?.count === 0) {
      console.log("Attempting to fix missing job posting limits...");
      const { error } = await supabase
        .from('job_posting_limits')
        .insert({
          user_id: user.id,
          monthly_post_limit: 1,
          monthly_posts_used: 0,
          subscription_tier: 'free'
        });
      
      fixResults.limitsFixed = !error;
    }
    
    return {
      success: true,
      fixed: fixResults,
      user: user.id
    };
  } catch (error) {
    return {
      error: error instanceof Error ? error.message : String(error)
    };
  }
};
